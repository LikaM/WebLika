1.
SELECT id, cpu, memory FROM PC                   
  WHERE 
    memory = 3000;
  
SELECT hdd FROM PC
WHERE hdd =
(
    SELECT MIN(hdd)
    FROM PC
)
GROUP BY hdd;



SELECT count(hdd) as count_hdd, hdd FROM PC
WHERE hdd =
(
    SELECT MIN(hdd)
    FROM PC
)
GROUP BY hdd;
     

2.



3.
DATETIME - тип данных для хранения даты и времени
Хранит время в виде целого числа вида YYYY-MM-DD HH:MM:SS ('от 1000-01-01 00:00:00'
до '9999-12-31 23:59:59'), используя для этого 8 байтов. 
Это время не зависит от временной зоны. Оно всегда отображается при выборке точно так же,
как было сохранено, независимо от того какой часовой пояс установлен в MySQL.

TIMESTAMP - тип данных для хранения даты и времени.
Хранит 4-байтное целое число, равное количеству секунд, прошедших с полуночи 1 января 1970 года
по усреднённому времени Гринвича (т.е. нулевой часовой пояс, точка отсчёта часовых поясов).
('1970-01-01 00:00:01' UTC до '2038-01-19 03:14:07' UTC.)
При получении из базы отображается с учётом часового пояса. Часовой пояс может быть задан
в операционной системе, глобальных настройках MySQL или в конкретной сессии.
Сохраняется всегда количество секунд по UTC (универсальное координированное время,
солнечное время на меридиане Гринвича), а не по локальному часовому поясу. 

Ещё одно отличие! TIMESTAMP по умолчанию NOT NULL, а его значение по умолчанию равно NOW().
(Формат YYYY-MM-DD HH:MM:SS)

тип TIMESTAMP используем для хранения дат и времени свершения событий нашего времени (текущих
(логирование,  даты размещения статей, добавления товаров, оформления заказов) и предстоящих
в обозримом будущем событий (выходы новых версий, календари и планировщики и т.д)), 
а DATETIME - для хранения дат и времени свершения исторических событий, 
или событий глубокого будущего (дни рождений, даты выпуска продуктов, избрания президентов,
запуски космических ракет и т.д.)).

TIMESTAMP хранит значение в UTC. При сохранении значения оно переводится из текущего временной 
зоны в UTC, а при его чтении - во время текущей временной зоны из UTC. 

       
4.

SELECT c.name FROM course c
JOIN student_course sc ON (sc.course_id=c.sourse_id)
WHERE student_id = 1;

        
                   
5. Да                   
                          
6.                                      

SELECT DISTINCT name_field FROM table;

Еще DISTINCT применяется внутри некоторых функций.
COUNT(DISTINCT name) - кол-во записей с разными name не равными NULL
SUM(DISTINCT x) - сумма разных x не равных NULL


7.                    


8.
HAVING - применяется для фильтрации функций и столбцов сгруппированных при помощи GROUP BY
указанных в SELECT.


Другими словами применяется для агрегатных функций(COUNT(), MAX() ...) и столбцов указанных
в выражении SELECT и обработанных GROUP BY. Если нужно использовать что-то, что не указанно
в SELECT, то лучше использовать WHERE.

Порядок выполнения такой:
1. В SELECT указываем нужные столбцы или агрегатные функции(то с чем будем работать в GROUP BY
 и HAVING)
2. В GROUP BY пишем по какому столбцу или функции их группируем
3. В HAVING пишем условие фильтровки результата GROUP BY 

Применяется последним и не оптимизируется. При использовании не по назначению на больших
таблицах будут временные задержки.